1.	Założenia:
	-Alokacja ciągła
	-Rozmiar  3704 bajtów
	-Odporność na awarię w trakcie operacji krytycznych
	-Proste czynności naprawcze
	-Bez dostępu współbieżnego
2.	Założenia Szczegółowe:
	-56 bloków pamięci po 64 bajty
	-Maksymalnie 16 deskryptorów plików
	-Blok kontrolny zapewniający transakcyjność operacji krytycznych
	-Nazwa pliku maksymalnie 4 znaki
	-Po włączeniu systemu plików sprawdzane jest, czy żadna operacja nie zostałą przerwana w trakcie, jesli tak wywoływana jest funkcja naprawcza
3.	Pola pamięci:

	-- 4 bajty --
	-Sekcja krytyczna - Przechowuję informację na temat ostatniej wykonywanej operacji. Wykorzystywany do dokończenia operacji przy nagłym przerwaniu:
		-typ operacji					1 bajt			-1 = pusty 	0 = usuwanie pliku 	1 = zapisywanie pliku
		-indeks w tablicy deksryptorów	1 bajt
		-nowy indeks bloku pamięci		1 bajt
		-rozmiar wykonywanej operacji	1 bajty			
		
	-- 112 bajtów --
	-Tablica deskryptorów plików - Przechowują informację na temat zapisanych na dysku plików:
		-indeks bloku w pamięci			1 bajt 			-2 = deskryptor nie używany		-1 = plik stworzony, pamięć jeszcze nie przydzielona	
		-rozmiar						1 bajt
		-nazwa 							4 bajty
		
	-- 4 bajtów --
	-Mapa bloków wolnych - Przechowuje informacji, które bloki pamięci są wolne, które zajęte:
		-4 bajtów, dla każego segmentu 1 bit opowiada 0 = wolny	1 = zajęty		8 bitów wolnych bez przydzielonego segmentu
		
	-- 3584 bajtów --
	-Przestrzeń pamięciowa:
		- 3584 bajty
		
4.	Efektynowść pamięci:
	
	3584 /  3704 ≈ 96.7%
	
5.	Dostępne operacje:
	Używane skróty:
		TDP 	- 	tablica deskryptorów plików
		TDOP 	-	tablica deskryptorów otwartych plików
		MBW 	- 	mapa bloków wolnych
		SK		-	sekcja krytyczna
	1. Open file(nazwa pliku)
	{
		indeks = Przeszukaj po nazwie pliku TDP i znajdź odpowiedający mu indeks i go zwróć. 
			Jeśli nie istnieje znajdź wolne miejsce w TDP na plik i ustaw indeks bloku na -1, rozmiar na 0 i zapisz nazwę i zwróć indeks TDP pod którym został zapisany.
		Sprawdź po indeks czy do TDOP jest ten idenks wpisany. Jeśli nie jest kontynuj.
		Znajdź wolne miejsce w TDOP i zapisz tam indeks i bajty wskazujące na adres w pamięci pliku na 0
	}
	
	2. Close file(nazwa pliku)
	{
		indeks = Przeszukaj po nazwie pliku TDP i znajdź odpowiedający mu indeks i go zwróć. Jeśli nie ma, zakończ funkcję
		Sprawdź po indeks czy do TDOP jest ten idenks wpisany. Jeśli jest, to nadpisz 0 na -1 
	}
	3. Read from file(indeksTDP)
	{
		wskaźnik = na podstawie indeksuTDP znajdź w TDOP blok odpowiadający czytanemu pliku i zapisz wartość wskaźnika na którego wskazuje
		Odczytaj z TDP indeks bloku w pamięci i rozmiar i przejdź do niego
		Literuj, odczytuj dane od offsetu na który wskazuje wskaźnik przez pamięć aż do momentu, gdy wskaźnik wyrówna się z rozmiarem.
		Zwróć wtedy odczytane dane
	}
	4.Save to file(indeksTDP, dane)
	{
		Na podstawie indeksuTDP znajdź w TDOP blok odpowiadający temu plikowi, jesli jest kontynuj.
		rozmiar, indeks bloku w pamięci = znajdź na podstawie indeksTDP w TDP.
		// Znajdujemy od jakiego segmentu w pamięci możemy zacząć zapisywanie
		Jeśli indeks = -1
			Odczytaj rozmiar danych i wylicz ile segmentów pamięci będzie zajmować i na podstawie MPW znajdź wolne miejsce w pamięci.
		Inaczej Jeśli rozmiar < dane.rozmiar
			wylicz ile segmentów pamięci będzie zajmować i na podstawie MBW, najpierw sprawdź czy nowy rozmiar da się nadpisać od już zajmowanego indeksu, jesli nie znajdź wolne miejsce w pamięci.
		//	Jeśli rozmiar > dane.rozmiar, to na pewno będziemy w stanie zapisać dany plik od indeksu bloku, więc nie musimy wykonywać żadnych dodatkowych operacji
		Zapisz dane od znalezionego wolnego segmentu.
		Zapisz do SK typ akcji jako 1, indeks bloku deskryptorów jako indeksTDP, nowy indeks bloku pamięci jako początkowy indeks wolnego segmentu, rozmiar jako dane.rozmiar
		Uaktualnij w MBW bity na 1 odpowiadające odpowiednim zajętych segmentow w pamięci 
			i jeśli indeks inny od indeksu znalezionego wolnego segmentu na podstawie rozmiar i przedtem znalezionego indeksu bloku w pamięci ustaw odpowiednie bity na 0
		Uaktualnij TDP na podstawie indeksTDP i zapisz jako indeks bloku w pamięci poczatkowy indeks znalezionego wolnego segmentu i rozmiar jako dane.rozmiar
		Zmień wartość w SK typu akcji na -1
		
	}
	5.Delete file(nazwa pliku)
	{
		indeksTDP, rozmiar = Przeszukaj po nazwie pliku TDP i znajdź odpowiedający mu indeks, rozmiar i je zwróć. Jeśli nie ma, zakończ funkcję
		Zapisz do SK typ akcji jako 0, indeks bloku deskryptora jako TDP, indeks bloku pamięci jako odczytany TDP oraz znaleziony rozmiar
		Oblicz na podstawie rozmiaru ile segmentów pamięci zajmował plik i zaktualizuj MBW.
		Wróc do znalezionego przedtem bloku w TDP i ustaw indeks bloku pamięci na -2
		Zmień wartość w SK typu akcji na -1
	}
	//funkcja naprawcza wywołująca się po starcie systemu
	6.Repair()
	{
		Sprawdź czy w SK typ akcji jest != -1
		Jeśli = 1
			Sprawdź w TDP na podstawie indeksuTDP czy zapisany tam indeks bloku pamięci jest taki sam jak nowy indeks pamięci zapisany w SK.
			Jeśli nie:
				zaktualizuj na podstawie indeksu bloka pamięci i rozmiaru starych danych odpowiednie pola MBW na 0
			Zaktualizuj odpowiednie miejsce w TDP informacjami z SK zmieniając indeks bloka pamięci na nowy indeks pamięci z SK oraz romzar na nowy rozmiar zapisany w SK
			Zmień wartość w SK typu akcji na -1
		Jeśli = 0
			Znajdź w TDP na podstawie indeksuTDP z SK indeks segmentu pamięci oraz rozmiar
			oblicz na podstawie rozmiaru ile segmentów pamięci zajmował plik i zaktualizuj MBW.
			wróc do znalezionego przedtem bloku w TDP i ustaw indeks bloku pamięci na -2
			Zmień wartość w SK typu akcji na -1
	}
6. Opis symulacji
	//fs.cpp
	Stworzyłem klasę FileSystem, która posiada zmienne odpowiadające polą pamięci i ma dwie funkcje write i repair, które symulują działanie zapisywania i naprawy systemu.
	Jest też funkcja create_file, ale ona została stworzona tylko na potrzeby zapisania informacji do tablicy deksryptorów plików i nie jest funkcjonalna. 
	//main.cpp, results.md
	W main testuje 3 możliwe przerwania zapisywania i od razu później je naprawiam i każe systemowi, żeby wypisał swoją zawartość, wyniki w results.md
	1 - od razu po zapisaniu danych do sekcji krytycznej
	2 - po ustawioniu w mapie bloków wolnych odpowiednich plików na 1
	3 - zaraz przed zmianą indeksu or rozmiaru w tablicy deksryptorów pliku
	4 - po zapisaniu do tablicy deskrypotra plików nowego indeksu, ale nie rozmiaru
	Po każdym przerwaniu a później naprawieniu system wyświetla dane tak jakby doszło do normalnego zapisanie, więc naprawa przebiega poprawnie